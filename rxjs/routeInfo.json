{"template":"../src/Library/rxjs/index.js","sharedHashesByProp":{},"data":{"handle":"rxjs","library":{"name":"RxJS","version":"6.4.0","description":"Reactive Extensions For JavaScript","examples":{"interval":"const { rxObserver } = require('api/v0.3');\nconst { interval } = require('rxjs');\nconst { take } = require('rxjs/operators');\n\ninterval(5).pipe(\n    take(10)\n  )\n  .subscribe(rxObserver());\n","timer":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { take } = require('rxjs/operators');\n\n\n// Will emit once\ntimer(10)\n  .subscribe(rxObserver('timer(10)'));\n\n// Will start emiting after 10ms timeout\n// with 5ms interval\ntimer(10, 5).pipe(\n    take(4)\n  )\n  .subscribe(rxObserver('timer(10, 5)'));\n","from":"const { rxObserver } = require('api/v0.3');\nconst { from } = require('rxjs');\n\n// from Array\nfrom([ 5, 10, 20 ])\n  .subscribe(rxObserver('from([5, 10, 20])'));\n\n// from string\nfrom('Hello')\n  .subscribe(rxObserver(`from('Hello')`));\n\n// NOTE: also check the `fromPromise` example\n","fromPromise":"const { rxObserver } = require('api/v0.3');\nconst { from } = require('rxjs');\n\nconst promise = new Promise((resolve, reject)=>{\n  setTimeout(() => resolve('done'), 10);\n});\n\nfrom(promise)\n  .subscribe(rxObserver('from(promise)'));\n\n// NOTE: also check the `from` example\n","of":"const { rxObserver } = require('api/v0.3');\nconst { of } = require('rxjs');\n\nof(1)\n  .subscribe(rxObserver());\n","defer":"const { rxObserver } = require('api/v0.3');\nconst { defer, of } = require('rxjs');\n\n// decides later what observable to return\nconst source$ = defer(()=>{\n  if (Date.now() < 3) {\n    return of('🐦');\n  }\n\n  return of('🦉');\n});\n\n// subsctibe at T0\nsource$.subscribe(rxObserver('Early bird'));\n\n// delayed subscription\nsetTimeout(()=>{\n  source$.subscribe(rxObserver('Night owl'));\n}, 5);\n","iif":"const { rxObserver } = require('api/v0.3');\nconst { iif, of } = require('rxjs');\n\n// decides later which observable to return\nconst source$ = iif(\n  ()=> Date.now() < 3 // predicate\n  , of('🐦')          // true\n  , of('🦉')          // false\n);\n\n// subsctibe at T0\nsource$.subscribe(rxObserver('Early bird'));\n\n// delayed subscription\nsetTimeout(()=>{\n  source$.subscribe(rxObserver('Night owl'));\n}, 5);\n","constructor":"const { rxObserver } = require('api/v0.3');\nconst { Observable } = require('rxjs/Rx');\n\n\nconst source$ = new Observable(observer=>{\n  let index = 0;\n  const id = setInterval(()=>{\n    observer.next(index++);\n  }, 10);\n  \n  return ()=>{\n    clearInterval(id);\n  };\n});\n\nsource$\n  .take(5)\n  .subscribe(rxObserver());\n","filter":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { filter, take } = require('rxjs/operators');\n\n\nconst source$ = timer(0, 5).pipe(\n    take(4)\n  );\n\nconst result$ = source$.pipe(\n    filter(x => x % 2)\n  );\n\nsource$.subscribe(rxObserver());\nresult$.subscribe(rxObserver());\n","find":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { find, take } = require('rxjs/operators');\n\n\nconst source$ = timer(0, 5).pipe(\n    take(4)\n  );\n\nconst result$ = source$.pipe(\n    find(x => x > 1)\n  );\n\nsource$.subscribe(rxObserver());\nresult$.subscribe(rxObserver());\n","buffer":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { buffer, take } = require('rxjs/operators');\n\n\nconst source$ = timer(0, 3).pipe(\n    take(10)\n  );\n\nconst trigger$ = timer(0, 7).pipe(\n    take(5)\n  );\n\nconst buffered$ = source$.pipe(\n    buffer(trigger$)\n  );\n\nsource$.subscribe(rxObserver('source'));\ntrigger$.subscribe(rxObserver('trigger'));\nbuffered$.subscribe(rxObserver('buffered'));\n","mergeMap":"const { rxObserver, palette } = require('api/v0.3');\nconst { Observable } = require('rxjs/Rx');\n\n// stream for coloring\nconst palette$ = Observable.from(palette);\n\nconst source$ = fromDelayed([ 5, 10, 20 ])\n  // get color for each item\n  .zip(palette$, Marble);\n\nconst mergeMap$ = source$\n  .mergeMap(x=> Observable\n    .timer(0, 3)\n    .take(3)\n    // inherit color from the source$ stream\n    .map(y => Marble(y, x.color)));\n\nsource$.subscribe(rxObserver());\nmergeMap$.subscribe(rxObserver());\n\n\n// helpers\n// creates a colored Marble\nfunction Marble(value,color) {\n  return {\n    valueOf: ()=>value\n    , color\n  };\n}\n\n// like .from, but items are delayed by their value\nfunction fromDelayed (arr) {\n  return Observable\n    .from(arr)\n    .delayWhen(x=>Observable.timer(x));\n}\n","switchMap":"const { rxObserver, palette } = require('api/v0.3');\nconst { Observable } = require('rxjs/Rx');\n\n// stream for coloring\nconst palette$ = Observable.from(palette);\n\nconst source$ = fromDelayed([ 5, 10, 20 ])\n  // get color for each item\n  .zip(palette$, Marble);\n\nconst switchMap$ = source$\n  .switchMap(x=> Observable\n    .timer(0, 3)\n    .take(5)\n    // inherit color from the source$ stream\n    .map(y=>Marble(y, x.color)));\n\nsource$.subscribe(rxObserver());\nswitchMap$.subscribe(rxObserver());\n\n\n// helpers\n// creates a colored Marble\nfunction Marble(value,color) {\n  return {\n    valueOf: ()=>value\n    , color\n  };\n}\n\n// like .from, but items are delayed by their value\nfunction fromDelayed (arr) {\n  return Observable\n    .from(arr)\n    .delayWhen(x=>Observable.timer(x));\n}\n","exhaustMap":"const { rxObserver, palette } = require('api/v0.3');\nconst { Observable } = require('rxjs/Rx');\n\n// stream for coloring\nconst palette$ = Observable.from(palette);\n\nconst source$ = fromDelayed([ 5, 10, 20 ])\n  // get color for each item\n  .zip(palette$, Marble);\n\nconst exhaustMap$ = source$\n  .exhaustMap(x=> Observable\n    .timer(0, 3)\n    .take(4)\n    // inherit color from the source$ stream\n    .map(y=>Marble(y, x.color)));\n\n\nsource$.subscribe(rxObserver());\nexhaustMap$.subscribe(rxObserver());\n\n\n// helpers\n// creates a colored Marble\nfunction Marble(value,color) {\n  return {\n    valueOf: ()=>value\n    , color\n  };\n}\n\n// like .from, but items are delayed by their value\nfunction fromDelayed (arr) {\n  return Observable\n    .from(arr)\n    .delayWhen(x=>Observable.timer(x));\n}\n","concatMap":"const { rxObserver, palette } = require('api/v0.3');\nconst { Observable } = require('rxjs/Rx');\n\n// stream for coloring\nconst palette$ = Observable.from(palette);\n\nconst source$ = fromDelayed([ 5, 10, 20 ])\n  // get color for each item\n  .zip(palette$, Marble);\n\nconst concatMap$ = source$\n  .concatMap(x=> Observable\n    .interval(5)\n    .take(3)\n    // inherit color from the source$ stream\n    .map(y=>Marble(y, x.color)));\n\n\nsource$.subscribe(rxObserver());\nconcatMap$.subscribe(rxObserver());\n\n\n// helpers\n// creates a colored Marble\nfunction Marble(value,color) {\n  return {\n    valueOf: ()=>value\n    , color\n  };\n}\n\n// like .from, but items are delayed by their value\nfunction fromDelayed (arr) {\n  return Observable\n    .from(arr)\n    .delayWhen(x=>Observable.timer(x));\n}\n","windowToggle":"const { rxObserver } = require('api/v0.3');\nconst { timer, merge, Subject } = require('rxjs');\nconst { windowToggle, take, flatMap, mapTo } = require('rxjs/operators');\n\n\nconst source$ = timer(0, 10).pipe(take(10));\n\nconst windowOn$ = new Subject();\nconst windowOff$ = new Subject();\n\nconst result$ = source$.pipe(\n  // filter values between on-off pairs\n  windowToggle(\n    windowOn$,\n    ()=>windowOff$\n  ),\n\n  // flattern window values\n  flatMap(v=>v)\n);\n\n// trigger ONs and OFFs\nwindowOn(15);\nwindowOff(35);\n\nwindowOn(75);\nwindowOff(85);\n\n\n// subscriptions\nsource$.subscribe(rxObserver('source'));\nresult$.subscribe(rxObserver('result'));\nmerge(\n    windowOn$.pipe(mapTo('on')),\n    windowOff$.pipe(mapTo('off'))\n  )\n  .subscribe(rxObserver('switch'));\n\n\n// helpers\nfunction windowOn(delay){\n  return setTimeout(()=>{\n    windowOn$.next(void 0);\n  }, delay);\n}\n\nfunction windowOff(delay){\n  return setTimeout(()=>{\n    windowOff$.next(void 0);\n  }, delay);\n}\n","expand":"const { rxObserver } = require('api/v0.3');\nconst { of, timer, EMPTY } = require('rxjs');\nconst { expand, mapTo } = require('rxjs/operators');\n\nof(1).pipe(\n    expand(value =>\n      value < 5\n      ? timer(5).pipe(mapTo(++value))\n      : EMPTY\n    )\n  )\n  .subscribe(rxObserver());\n","toArray":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { take, toArray } = require('rxjs/operators');\n\n\n// create a timer with 3 events\nconst source$ = timer(0, 5).pipe(\n    take(3)\n  );\n\n// collapse all events into one array\nconst result$ = source$.pipe(\n    toArray()\n  );\n\nsource$.subscribe(rxObserver('timer(0, 10).take(4)'));\nresult$.subscribe(rxObserver('.toArray()'));\n","throwError":"const { rxObserver } = require('api/v0.3');\nconst { timer, throwError } = require('rxjs');\nconst { switchMap } = require('rxjs/operators');\n\ntimer(10)\n  .pipe(\n    switchMap(()=>\n      throwError('Err!')\n    )\n  )\n  .subscribe(rxObserver());\n","catch":"const { rxObserver } = require('api/v0.3');\nconst { timer, throwError, of } = require('rxjs');\nconst { switchMap, catchError } = require('rxjs/operators');\n\nconst error$ = timer(5).pipe(\n    switchMap(() => throwError('oh'))\n  );\n  \nconst catch$ = error$.pipe(\n    catchError(err => of(err))\n  );\n\n\nerror$.subscribe(rxObserver());\ncatch$.subscribe(rxObserver());\n","retry":"const { rxObserver, palette } = require('api/v0.3');\nconst { timer, from } = require('rxjs');\nconst { zip, map, retry } = require('rxjs/operators');\n\nconst error$ = timer(0, 5).pipe(\n    map(x=>{\n      if (x>2) { throw 'Bam!' }\n      return x;\n    })\n  );\n\n// same error$ stream, just frozen colors\nconst errorColorized$ = error$.pipe(\n    zip(from(palette), Marble)\n  );\n\n// retry 2 times\nconst retry$ = errorColorized$.pipe(\n    retry(2)\n  );\n\n\nerror$.subscribe(rxObserver());\nretry$.subscribe(rxObserver());\n\n\n// helpers\n// creates a colored Marble\nfunction Marble(value,color) {\n  return {\n    valueOf: ()=>value\n    , color\n  };\n}\n","retryWhen":"const {rxObserver} = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { map, tap, retryWhen, delayWhen } = require('rxjs/operators');\n\nconst source$ =\n  timer(0, 100).pipe(\n    map(val => {\n      if (val == 1) {\n        throw 'Err';\n      }\n      return val;\n    })\n  );\n\nconst result$ = source$.pipe(\n    retryWhen(errors =>\n      // here Errors are just events\n      errors.pipe(\n        // show error messages thread\n        tap(rxObserver('Error messages')),\n        // will restart with increasing delay\n        delayWhen((_, index) => timer(index * 50))\n      )\n    )\n);\n\nsource$.subscribe(rxObserver('source$'));\nresult$.subscribe(rxObserver('result$'));\n\n// a modification of\n// https://www.learnrxjs.io/operators/error_handling/retrywhen.html\n","onErrorResumeNext":"const { rxObserver, palette } = require('api/v0.3');\nconst { timer, onErrorResumeNext, throwError, of } = require('rxjs');\nconst { map, take, concat, ignoreElements } = require('rxjs/operators');\n\n\nconst failTimer = timer(5).pipe(\n    ignoreElements(),\n    concat(throwError('Ouch!'))\n  );\n\nconst fineTimer = timer(5).pipe(\n    ignoreElements(),\n    concat(of('Ok!'))\n  );\n\nconst strategicTimer = onErrorResumeNext(\n    failTimer,\n    fineTimer\n  );\n\nfailTimer.subscribe(rxObserver('fail timer'));\nfineTimer.subscribe(rxObserver('fine timer'));\nstrategicTimer.subscribe(rxObserver('strategic'));\n","share":"const { rxObserver, palette } = require('api/v0.3');\nconst { Observable } = require('rxjs/Rx');\n\nconst palette$ = Observable.from(palette);\n\nconst source$ = Observable.timer(0, 5)\n  // add color to items\n  .zip(palette$, Marble);\n\nconst shared$ = source$.share();\n\n// creating observers for source$\nconst a = rxObserver('source$');\nconst b = rxObserver('delayed subscription');\nsource$.take(5).subscribe(a);\n\n// creating observers for shared$\nconst c = rxObserver('shared$');\nconst d = rxObserver('delayed subscription');\nshared$.take(5).subscribe(c);\n\n// delayed subscriptions\nsetTimeout(()=>{\n  source$.take(5).subscribe(b);\n  shared$.take(5).subscribe(d);\n}, 10);\n\n\nfunction Marble(value,color) {\n  return {\n    valueOf: ()=>value\n    , color\n  };\n}\n","zip":"const { rxObserver } = require('api/v0.3');\nconst { timer, from } = require('rxjs');\nconst { zip, take } = require('rxjs/operators');\n\n\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz';\nconst alphabet$ = from(alphabet);\n\ntimer(0, 5).pipe(\n    zip(alphabet$, (digit, letter)=>digit+letter),\n    take(10)\n  )\n  .subscribe(rxObserver());\n","forkJoin":"const { rxObserver } = require('api/v0.3');\nconst { timer, forkJoin } = require('rxjs');\nconst { mapTo, take } = require('rxjs/operators');\n\n\nconst a$ = timer(10).pipe(mapTo('a'));\nconst b$ = timer(0, 10).pipe(take(3));\n\nconst result$ = forkJoin(a$, b$);\n\na$.subscribe(rxObserver('a$'));\nb$.subscribe(rxObserver('b$'));\nresult$.subscribe(rxObserver('forkJoin(a$, b$)'));","combineLatest":"const { rxObserver } = require('api/v0.3');\nconst { timer, combineLatest } = require('rxjs');\nconst { take } = require('rxjs/operators');\n\n\nconst a$ = timer(0, 10).pipe(\n    take(5)\n  );\n\nconst b$ = timer(0, 4).pipe(\n    take(7)\n  );\n\nconst result$ = combineLatest(a$, b$);\n\na$.subscribe(rxObserver('a$'));\nb$.subscribe(rxObserver('b$'));\nresult$.subscribe(rxObserver('result$'));\n","tap":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { tap, take } = require('rxjs/operators');\n\ntimer(0, 5)\n  .pipe(\n    take(10),\n    tap(v => console.log('tap', v))\n  )\n  .subscribe(rxObserver('tap()'));\n\n\n// Compat version with .do\nconst { Observable } = require('rxjs/Rx');\nObservable\n  .timer(0, 5)\n  .take(10)\n  .do(v => console.log('do', v))\n  .subscribe(rxObserver('.do()'));\n","finalize":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { finalize } = require('rxjs/operators');\n\ntimer(5)\n  .pipe(\n    finalize(()=>\n      console.log(`Finished @ ${ Date.now() }ms`)\n    )\n  )\n  .subscribe(rxObserver());\n","timeInterval":"\nconst { rxObserver } = require('api/v0.3');\nconst { interval, merge } = require('rxjs');\nconst { timeInterval, take, map } = require('rxjs/operators');\n\n// Indicates time passed since previous value\n\nmerge(\n  interval(5),\n  interval(7)\n)\n  .pipe(\n    take(10),\n    timeInterval(),\n    map(({ interval }) => `+${interval}`)\n  )\n  .subscribe(rxObserver(''));\n","delay":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { delay, take } = require('rxjs/operators');\n\n// basic timer\nconst timer$ = timer(0, 10)\n  .pipe(\n    take(5)\n  );\n\n// same timer, values delayed by 15ms\nconst delayed$ = timer$.pipe(\n    delay(15)\n  );\n\ntimer$.subscribe(rxObserver('Basic timer'));\ndelayed$.subscribe(rxObserver('Delayed by 15ms'));\n","delayWhen":"const { rxObserver } = require('api/v0.3');\nconst { from, timer } = require('rxjs');\nconst { delayWhen } = require('rxjs/operators');\n\nfrom([ 0, 15, 20, 25, 5, 10 ])\n  .pipe(\n    delayWhen(x => timer(x))\n  )\n  .subscribe(rxObserver());\n","dematerialize":"const { rxObserver } = require('api/v0.3');\nconst { timer, throwError, Notification } = require('rxjs');\nconst { switchMap, materialize, dematerialize, delay, map } = require('rxjs/operators');\n\n\nconst source$ = timer(5).pipe(\n  switchMap(() => throwError('Err!'))\n);\n\nconst result$ = source$.pipe(\n  // turn all events on stream into Notifications\n  materialize(),\n  // delay error by 5ms\n  delay(5),\n  // turn error into a value\n  map(n => new Notification('N', n.error, undefined)),\n  // turn Notifications back to events on stream\n  dematerialize()\n);\n\nsource$.subscribe(rxObserver('source$'));\nresult$.subscribe(rxObserver('result$'));\n","repeat":"\nconst { rxObserver } = require('api/v0.3');\nconst { timer, iif, of } = require('rxjs');\nconst { repeat, delay } = require('rxjs/operators');\n\n// repeat:\n// resubscribe when source stream completes\n\n// basic example\ntimer(5)\n  .pipe(\n    repeat(5)\n  )\n  .subscribe(rxObserver());\n\n// when source stream completes -- repeat\n// subscribes again and gets a new stream\niif(\n  () => Date.now() < 10\n  , of('0..10')\n  , of('10+')\n)\n  .pipe(\n    delay(5),\n    repeat(5)\n  )\n  .subscribe(rxObserver());\n","timeout":"const { rxObserver } = require('api/v0.3');\nconst { from, timer } = require('rxjs');\nconst { delayWhen, timeout } = require('rxjs/operators');\n\nconst source$ = from([ 0, 10, 20, 45 ])\n  .pipe(\n    delayWhen(x => timer(x))\n  );\n\nconst result$ = source$.pipe(\n  timeout(20)\n);\n\nsource$.subscribe(rxObserver());\nresult$.subscribe(rxObserver());\n","pipe":"const { rxObserver } = require('api/v0.3');\nconst { timer } = require('rxjs');\nconst { filter,take } = require('rxjs/operators');\n\n\ntimer(0, 10)\n  .pipe(\n    take(10),\n    filter(x => x % 2)\n  )\n  .subscribe(rxObserver('Odd'));\n"},"groups":[{"name":"Creation","items":["of","from","fromPromise","interval","timer","defer","iif","constructor"]},{"name":"Combination","items":["zip","forkJoin","combineLatest"]},{"name":"Error handling","items":["throwError","catch","retry","retryWhen","onErrorResumeNext"]},{"name":"Transformation","items":["filter","find","buffer","mergeMap","switchMap","exhaustMap","concatMap","windowToggle","expand","toArray"]},{"name":"Multicasting","items":["share"]},{"name":"Utility","items":["tap","finalize","timeInterval","delay","delayWhen","dematerialize","repeat","timeout","pipe"]}]}},"path":"rxjs"}
